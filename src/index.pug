doctype html
head
    title An introduction to HTML5 game development
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')

    //- minideck core files
    link(rel='stylesheet', href='minideck/minideck.css', type='text/css')
    script(src='minideck/minideck.js')

    //- remove these if you don't need syntax highlighting
    script(src='minideck/vendor/highlight.js')
    link(rel='stylesheet', href='minideck/vendor/highlight.css', type='text/css')

    //- your own theme
    link(rel='stylesheet', href='minideck/simple-theme.css', type='text/css')
body
    article#deck
        header
            progress
        section.title
            h1 An introduction#[br]to HTML5 game development
            p Belén Albeza
            p
                a(href='https://belenalbeza.com') belenalbeza.com
                |&nbsp;//&nbsp;
                a(href='https://twitter.com/ladybenko') @ladybenko
            p.breathe Deck:<br>
                a(href='https://belen-albeza.github.io/intro-gamedev') https://belen-albeza.github.io/intro-gamedev
        section.centered
            h1 I. Web tech

        section
            h1 Why HTML5 for games?
            ul
                li The power of an URL
                li Because we #[em can]
        section
            h1 HTML5 tech to support games
            ul
                li Drawing API's: Canvas (2D) and WebGL (3D)
                li Input: keyboard, mouse, touch, gyroscope, etc.
                li Web Audio API
                li Reliable timing: #[code requestAnimationFrame]
                li WebAssembly, WebVR, etc.
        section
            h1 How?
            ul
                li Code in #[strong JavaScript] and directly use these API's (maybe with the aid of libraries)
                li Use a #[strong multi-platform engine] that supports exporting to HTML5
        section
            h1 Engines
            ul
                li 3D
                    ul
                        li Unity (C#)
                        li Unreal (C++)
                li 2D
                    ul
                        li Game Maker (custom language)
                        li PICO-8 (Lua)
        section
            h1 JS engines/libraries
            ul
                li 2D
                    ul
                        li Phaser
                        li Pixi (drawing only)
                li 3D
                    ul
                        li Babylon.js
                        li PlayCanvas Engine
                        li THREE.js (drawing only)
        section.centered
            h1 II. Game development concepts

        section.centered
            h1 Basic structures

        section
            h1 FSM
            ul.cols
                li: ul
                    li Ultra-versatile: game states, AI, etc.
                    li Easy to implement (#[code switch]/polymorphism)
                li: img.figure(src='images/fsm.png')
        section
            h1 The game loop
            ul.cols
                li: ul
                    li Ideally render frames 60 times per second (#[strong 60 fps])
                    li Two steps each frame: #[strong update] and #[strong render]
                li: img.figure(src='images/game_loop.svg')
        section
            h1 Game states (I)
            ul.cols
                li: ul
                    li Each state represents a "screen" in the game (the main menu, a level…)
                    li They might be in a stack (for "modal" states) or in a FSM
                li: img.figure(src='images/game_states_all.png')
        section
            h1 Game states (II)
            ul.cols
                li: ul
                    li States might have a FSM in the inside to handle the different stages
                li: img.figure(src='images/game_state.png')



        section.centered
            h1 Sprites
        section
            h1 Sprites
            ul.cols
                li: ul
                    li Images with movement/behaviour
                    li They can intereact between them #[small (i.e. a bullet destroying an enemy alien)]
                    li They can be animated
                li: img.figure(src='images/sonic.png')
        section
            h1 Keyframe-based animations
            ul.cols
                li: ul
                    li #[b frame-by-frame]: a different picture is used for every part of the animation
                    li There is no interpolation
                    li Usually stored in #[b spritesheets] for performance
                li
                    img.figure(src='images/spritesheet.png')
                    img.figure.breathe(src='images/spritesheet_animated.gif')
        section
            h1 Skeletal animation
            ul.cols
                li: ul
                    li "South Park"-like
                    li A sprite is decomposed into parts that are rotated, moved, etc.
                    li There is interpolation
                    li More smooth… but may look odd if not combined with keyframes
                li: img.figure(src='images/spine2d.jpg')

        section
            h1 Entities and the game world
            ul.cols
                li: ul
                    li #[b Entities]: sprites, UI elements, particle systems, texts, etc.
                    li They can be organised in a #[b tree structure] that represents the game world
                    li If a tree, #[b hierarchical relationships] can be useful for handling entities relatively to a parent
                li
                    img.figure(src='images/game_tree.svg')
                    p: small See #[a(href='https://lab.belenalbeza.com/games/ldjam-32/', target='_blank') #[i Metal vs Hipsters]]

        section
            h1 Sprite pools and recycling (I)
            ul.cols
                li: ul
                    li It's useful to group similar sprites in #[strong lists] (f.ex: to check collisions between all the lasers and all the enemies)
                    li Pools can be considered (or not) entities.
        section
            h1 Sprite pools and recycling (II)
            ul.cols
                li: ul
                    li The problem: #[b performance issues] when creating and releasing sprites
                    li Solution: don't release sprites, mark them as "zombies" and re-use them
                li: img.figure(src='images/recycle.svg')

        section.centered
            h1 Physics
        section
            h1 Old-school physics
            ul.cols
                li: ul
                    li Classical mechanics equations
                    li Relatively fast and easy to implement
                    li Need the #[b delta] time
        section
            h1 Physics engine
            ul.cols
                li: ul
                    li Very powerful and with interesting features
                    li Support for solid bodies, joints, ropes, etc.
                    li They map game entities to physical bodies
                    li Easy to use, but hard to fine-tune
                li: img.figure(src='images/physics.svg')

        section.centered
            h1 Collision detection

        section
            h1 Pixel-perfect
            ul.cols
                li: ul
                    li On a 2D graphic environment
                    li Precise… at the expense of performance
        section
            h1 Bounding boxes
            ul.cols
                li: ul
                    li Wrap the sprites in rects or circles and check for intersections
                    li The fastest method
                    li Trivial to implement
                    li Variants to support rotations: OBB, AABB
                li: img.figure(src='images/bboxes.svg')
        section
            h1 Polygon-based
            ul.cols
                li: ul
                    li Separating Axis Theorem
                    li Most physics engines use this method
                    li Convex polygons only!

        section.centered
            h1 World and levels
        section
            h1 Scroll
            ul.cols
                li: ul
                    li Your level can be bigger than the screen
                    li Parallax effect (layers moving at different speed)
                    li Camera to follow a character
        section
            h1 Grids
            ul.cols
                li: ul
                    li Map your world/level into a logical grid
                    li Grids are usually square, but can be rects, hexagons…
                    li Easy to perform checks and implement the game logic
                li: img.figure(src='images/nethack_grid.png')
        section
            h1 Tiles
            ul.cols
                li: ul
                    li Build up your world's graphics from tiny pieces (tiles)
                    li Widely used in classic games
                    li Can be easily mapped into a logical grid
                li: img.figure(src='images/square_tiles.png', width='100%')

        section.centered
            h1 Rendering
        section
            h1 A 2D scene with 3D graphics
            ul.cols
                li: ul
                    li Why? Performance
                    li The trick: orthogonal perspective
                    li Graphics are rendered as textures into quads
                li: img.figure(src='images/orthogonal_projection.png')
        section
            h1 Particles
            ul.cols
                li: ul
                    li Very cool to create effects: explosions, smoke, halos, etc.
                    li Can be as tiny as 1 pixel… (in classic games)
                    li …or made up of tiny polygons (3D games)
                li: img.figure(src='images/particles.jpg')
        section
            h1 Bitmap fonts
            ul.cols
                li: ul
                    li Store the characters of a font in a spritesheet
                    li Easy to implement if monospaced
                li: img.figure(src='images/bitmap_font.png').solid-bg
        section.centered
            h1 Thanks!
            p Questions?

    script.
        document.addEventListener('DOMContentLoaded', function () {
            let deck = new MiniDeck(
                document.querySelectorAll('#deck > section'),
                document.querySelector('#deck progress'));
        });

        if (hljs) { hljs.initHighlightingOnLoad();  }
